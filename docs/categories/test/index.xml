<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Test on Yee</title>
    <link>http://superdanby.github.io/Blog/categories/test.html</link>
    <description>Recent content in Test on Yee</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Mar 2017 11:20:00 +0800</lastBuildDate>
    
	<atom:link href="http://superdanby.github.io/Blog/categories/test/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Markdown Demo</title>
      <link>http://superdanby.github.io/Blog/markdowndemo.html</link>
      <pubDate>Tue, 21 Mar 2017 11:20:00 +0800</pubDate>
      
      <guid>http://superdanby.github.io/Blog/markdowndemo.html</guid>
      <description>Welcome to StackEdit! Hey! I&amp;rsquo;m your first Markdown document in StackEdit1. Don&amp;rsquo;t delete me, I&amp;rsquo;m very helpful! I can be recovered anyway in the Utils tab of the  Settings dialog.
Documents StackEdit stores your documents in your browser, which means all your documents are automatically saved locally and are accessible offline!
 Note:
 StackEdit is accessible offline after the application has been loaded for the first time. Your local documents are not shared between different browsers or computers.</description>
    </item>
    
    <item>
      <title>Test</title>
      <link>http://superdanby.github.io/Blog/test.html</link>
      <pubDate>Thu, 23 Feb 2017 23:20:00 +0800</pubDate>
      
      <guid>http://superdanby.github.io/Blog/test.html</guid>
      <description>ye2s  Ouch!  OMG! This is sooo g o o d 
#!cpp #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int MAX_N = 1e6; const int MAX_M = 1e3; int N, M; int A[MAX_N]; bool dp[MAX_M][MAX_M]; inline int mod(int a, int b) { return (a + b) % b; } int main() { scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;N, &amp;amp;M); for (int i = 0; i &amp;lt; N; i++) scanf(&amp;quot;%d&amp;quot;, &amp;amp;A[i]); if (N &amp;gt; M) { puts(&amp;quot;YES&amp;quot;); return 0; } // dp[i][j] = 前 i + 1 個數可否組出 mod m = j 的數 // dp[i][j] = true if dp[i - 1][(j - (a[i] mod m)) mod m] or // dp[i - 1][j] or // j = a[i] % m dp[0][A[0] % M] = true; for (int i = 1; i &amp;lt; N; i++) { dp[i][A[i] % M] = true; for (int j = 0; j &amp;lt; M; j++) { if (dp[i - 1][j] || dp[i - 1][mod(j - A[i] % M, M)]) { dp[i][j] = true; } } } puts(((dp[N - 1][0]) ?</description>
    </item>
    
  </channel>
</rss>